{
  "version": 3,
  "sources": ["../index.js"],
  "sourcesContent": ["(function () {\n  if (window.rtcstats) {\n    console.warn(\"[RTCStats] Already declared\");\n    return;\n  }\n\n  window.rtcstats = this;\n\n  // Test ID and Client IDs to help make the data identifiable\n  const test_id =\n    document.currentScript.getAttribute(\"test_id\") || crypto.randomUUID();\n  const client_id =\n    document.currentScript.getAttribute(\"client_id\") || crypto.randomUUID();\n  // How often each peer connection will generate stats\n  const report_interval =\n    document.currentScript.getAttribute(\"report_interval\") || 1;\n  // How often this script will log data\n  const write_interval =\n    document.currentScript.getAttribute(\"write_interval\") || 5;\n\n  const _config = {\n    report_interval: report_interval,\n    write_interval: write_interval,\n    test_id,\n    client_id,\n  };\n\n  // Reference all active WebRTC peer connections\n  const peerConns = [];\n\n  async function store(reportArray) {\n    console.info(\"RTCStats] Logging data...\", reportArray);\n    // Store report array here\n  }\n\n  async function logBatch(batchCollection) {\n    // Note: async function so main event loop is kept unblocked\n    const reportArray = [];\n    batchCollection.forEach((b) => {\n      // grab the reports and empty the array (batch is cleared)\n      const reports = b.splice(0, b.length).forEach((data) =>\n        reportArray.push({\n          test_id: _config.test_id,\n          data,\n        })\n      );\n    });\n\n    if (!reportArray.length) {\n      return;\n    }\n\n    store(reportArray);\n  }\n\n  /**\n   * -----------------------\n   * RTCPeerConnection shim\n   * -----------------------\n   */\n  class RTCStatsPeerConnection extends RTCPeerConnection {\n    constructor(config) {\n      super();\n\n      // Init\n      this.batch = []; // Array of reports collected\n      this.report_num = 0; // Current tick for timeseries\n      this.connection_id = crypto.randomUUID();\n\n      // Append to global array\n      peerConns.push(this);\n\n      console.warn(\"PeerConnection instantiated\", this);\n\n      // Listen for connection state, start harvesting when connected\n      this.addEventListener(\"connectionstatechange\", () => {\n        clearInterval(this._statsInterval);\n\n        if (this.connectionState === \"connected\") {\n          this._getStats(this.getStats());\n\n          // Start collecting data every TICK...\n          this._statsInterval = setInterval(() => {\n            if (this.connectionState !== \"connected\")\n              return clearInterval(this._statsInterval);\n\n            // Run an override of the getStats method\n            this._getStats(this.getStats());\n          }, _config.report_interval * 1000);\n        }\n      });\n    }\n\n    async _getStats(getStatsPromise) {\n      const stats = await getStatsPromise;\n      const rtcdata = Object.fromEntries(stats.entries());\n\n      if (!rtcdata) return;\n\n      this.batch.push({\n        clientId: _config.client_id,\n        testId: _config.test_id,\n        connectionId: this.connection_id,\n        reportNum: this.report_num,\n        ...rtcdata,\n      });\n\n      // Increment report number for timeseries\n      this.report_num += 1;\n    }\n  }\n\n  /**\n   * -----------------------\n   * Init method\n   * -----------------------\n   */\n  if (![\"test_id\", \"client_id\"].every((k) => k in _config)) {\n    console.warn(\"[RTCStats] Missing config keys. Exiting\");\n  } else {\n    console.info(`[RTCStats] Init with config:`, _config);\n    RTCPeerConnection = RTCStatsPeerConnection;\n\n    // Main write interval\n    setInterval(() => {\n      if (!peerConns.length) {\n        // No connected peers, do nothing\n        return;\n      }\n      // Create a batch of reports from each peer connection\n      const batchCollection = peerConns\n        .filter((pc) => pc.batch.length) // filter out PeerConnections with empty batches (no reports)\n        .map((pc) => pc.batch); // return the batch array containing all the reports (arbitrary amount)\n      if (batchCollection.length) {\n        logBatch(batchCollection);\n      }\n    }, _config.write_interval * 1000);\n  }\n})();\n"],
  "mappings": "OAAC,UAAY,CACX,GAAI,OAAO,SAAU,CACnB,QAAQ,KAAK,6BAA6B,EAC1C,MACF,CAEA,OAAO,SAAW,KAGlB,IAAMA,EACJ,SAAS,cAAc,aAAa,SAAS,GAAK,OAAO,WAAW,EAChEC,EACJ,SAAS,cAAc,aAAa,WAAW,GAAK,OAAO,WAAW,EAElEC,EACJ,SAAS,cAAc,aAAa,iBAAiB,GAAK,EAEtDC,EACJ,SAAS,cAAc,aAAa,gBAAgB,GAAK,EAErDC,EAAU,CACd,gBAAiBF,EACjB,eAAgBC,EAChB,QAAAH,EACA,UAAAC,CACF,EAGMI,EAAY,CAAC,EAEnB,eAAeC,EAAMC,EAAa,CAChC,QAAQ,KAAK,4BAA6BA,CAAW,CAEvD,CAEA,eAAeC,EAASC,EAAiB,CAEvC,IAAMF,EAAc,CAAC,EACrBE,EAAgB,QAASC,GAAM,CAE7B,IAAMC,EAAUD,EAAE,OAAO,EAAGA,EAAE,MAAM,EAAE,QAASE,GAC7CL,EAAY,KAAK,CACf,QAASH,EAAQ,QACjB,KAAAQ,CACF,CAAC,CACH,CACF,CAAC,EAEIL,EAAY,QAIjBD,EAAMC,CAAW,CACnB,CAOA,MAAMM,UAA+B,iBAAkB,CACrD,YAAYC,EAAQ,CAClB,MAAM,EAGN,KAAK,MAAQ,CAAC,EACd,KAAK,WAAa,EAClB,KAAK,cAAgB,OAAO,WAAW,EAGvCT,EAAU,KAAK,IAAI,EAEnB,QAAQ,KAAK,8BAA+B,IAAI,EAGhD,KAAK,iBAAiB,wBAAyB,IAAM,CACnD,cAAc,KAAK,cAAc,EAE7B,KAAK,kBAAoB,cAC3B,KAAK,UAAU,KAAK,SAAS,CAAC,EAG9B,KAAK,eAAiB,YAAY,IAAM,CACtC,GAAI,KAAK,kBAAoB,YAC3B,OAAO,cAAc,KAAK,cAAc,EAG1C,KAAK,UAAU,KAAK,SAAS,CAAC,CAChC,EAAGD,EAAQ,gBAAkB,GAAI,EAErC,CAAC,CACH,CAEA,MAAM,UAAUW,EAAiB,CAC/B,IAAMC,EAAQ,MAAMD,EACdE,EAAU,OAAO,YAAYD,EAAM,QAAQ,CAAC,EAE7CC,IAEL,KAAK,MAAM,KAAK,CACd,SAAUb,EAAQ,UAClB,OAAQA,EAAQ,QAChB,aAAc,KAAK,cACnB,UAAW,KAAK,WAChB,GAAGa,CACL,CAAC,EAGD,KAAK,YAAc,EACrB,CACF,CAOK,CAAC,UAAW,WAAW,EAAE,MAAOC,GAAMA,KAAKd,CAAO,GAGrD,QAAQ,KAAK,+BAAgCA,CAAO,EACpD,kBAAoBS,EAGpB,YAAY,IAAM,CAChB,GAAI,CAACR,EAAU,OAEb,OAGF,IAAMI,EAAkBJ,EACrB,OAAQc,GAAOA,EAAG,MAAM,MAAM,EAC9B,IAAKA,GAAOA,EAAG,KAAK,EACnBV,EAAgB,QAClBD,EAASC,CAAe,CAE5B,EAAGL,EAAQ,eAAiB,GAAI,GAlBhC,QAAQ,KAAK,yCAAyC,CAoB1D,GAAG",
  "names": ["test_id", "client_id", "report_interval", "write_interval", "_config", "peerConns", "store", "reportArray", "logBatch", "batchCollection", "b", "reports", "data", "RTCStatsPeerConnection", "config", "getStatsPromise", "stats", "rtcdata", "k", "pc"]
}
